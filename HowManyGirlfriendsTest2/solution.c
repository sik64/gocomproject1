#include "solution.h"
/*
< 문제 설명 >
solution 함수를 완성하세요.
solution 함수는 매개변수로 5*5 행렬 map[5][5]과 10개의 원소로 이뤄진 배열 move[10]을 받습니다.
주어진 map[5][5] 에서 자신의 위치(2)를 기준으로 주어진 move[10]대로 이동했을때 만나는 사람(1)의 수를 return합니다.

소스코드 실행시 저장된 테스트케이스를 자동으로 solution()함수의 인자로 넣어 차례대로 테스트 합니다.

Example))

map = {
	{0,0,0,0,1},
	{0,1,0,0,0}, 
	{0,0,0,2,0},
	{0,1,0,0,1},
	{0,0,0,0,0}
}

move = { 'w','a','a','s','s','d','d','d','w','w'}

2차원 행렬 map에서 2는 자신의 위치, 1은 다른 사람의 위치 이며 0은 빈 공간이다.
1차원 행렬 move 'w','a','s','d'는 상-우-하-좌 로 이동하는 것을 의미한다.

*주어진 map에서 2의 개수는 1개, 1의 개수는 랜덤, 1,2의 위치 또한 랜덤이다.
*2의 위치는 벽을 뚫고 이동할 수 없으며, 벽을 뚫어야 하는 움직임은 무효 처리된다.
*만났던 1을 다시만나는 경우 만남횟수는 카운트되지 않는다.

*/
int solution(int map[5][5], char move[10]) {

	int myY = 0;
	int myX = 0;
	int counter = 0;
	// map[5][5]을 돌며 자신(2)의 위치를 찾는 코드
	for (int y = 0; y < 5; y++) {
		for (int x = 0; x < 5; x++) {
			if (map[y][x] == 2) {
				myY = y;
				myX = x;
			}
		}
	}
	// move[10]의 원소에 따라 위치에 대응하는 변수를 변경하는 코드
	for (int i = 0; i < 10; i++) {
		switch (move[i]) {
		case 'w':
			if (myY != 0) myY--;
			break;
		case 'a':
			if (myX != 0) myX--;
			break;
		case 's':
			if (myY < 4) myY++;
			break;
		case 'd':
			if (myX < 4)
				myX++;
			break;
		default:
			// a,w,s,d가 아닌 경우 아무 조치 없이 넘어간다.
			break;
		}
		if (map[myY][myX] == 1) {
			// 1을 만났을 경우 counter를 증가시킨다.
			counter++;
			map[myY][myX] = 0;
			// 다시 만날 경우 count되지 않도록  0으로 만든다.
		}
	}

	int result = counter;

	return result;
}

//https://www.notion.so/siklab/5dbd834b8c73489e8cb2e48f4c1f7d8f?pvs=4#08b0d3110c8e4fd58ba9bdf997027c2c
		//1. 문제이해
		// // 2는 맵에 1개 뿐이다. 1의 개수,위치는 랜덤, 맵크기 고정, 움직임 횟수 고정
		//2. 알고리즘 구상
		// 2-1. 나의 위치 찾기
		// 2-2. move[i]대로 이동 후 해당 좌표의 사람유무 확인
		// 2-3. 카운팅
		// 2-4 예외처리 / 벽,회귀
		//3. 코딩

		// 난이도 조절
		// 1. 맵 사이즈 변화/고정 5*5 / 6*6 / 8*8
		// 2. 움직임 횟수 변화/고정 10 , 20 , 30
		// 3. 벽 마주 시 그 위치 그대로
		// 4. 돌아서 다시 만났을 때 카운트 x
		// 5. 가만히 있는 옵션 x 추가 w a d s x?

		// 링크로 구글드라이브의 파일과 발표자료를 나눠준다.
		// 시작 카운트
		// 10분 마다 힌트 투척

		//잘하기 위해서 
		// ppt이해도 
		// 정답 애니매이션
		// 코딩실력 뽐내기 / 문제는 쉬우면서 어떻게 코딩실력을 보여줄까
